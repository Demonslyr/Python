#! python2

from __future__ import print_function
from itertools import *
from decimal import Decimal
import math


def importData(filePath):
    f = open(filePath, "r")
    headers = []
    data = []
    for line in f:
        if "<" in line and ">" in line:
            continue
        if "[" in line and "]" in line:
            headers = line.translate(None, '[]').strip().split(' ')
            continue
        data.append(line.rstrip('\n').split(' '))
    return [headers, data]

def Symbolicise(data):
    symbols ={}
    distinctSet = []
    attCols = len(data[0])-1
    for column in range(0,attCols):
        for case in data:
            distinctSet.append(float(case[column]))
        distinctSet = sorted(set(distinctSet))
        symbols[str(distinctSet[0])] = str(distinctSet[0]) +".."+str((distinctSet[0]+distinctSet[1])/2)
        for itemIndx in range(1,len(distinctSet)-1):
            symbols[str(distinctSet[itemIndx])] = str((distinctSet[itemIndx]+distinctSet[itemIndx-1])/2) +".."+str((distinctSet[itemIndx]+distinctSet[itemIndx+1])/2)
        symbols[str(distinctSet[len(distinctSet)-1])] = str((distinctSet[len(distinctSet)-1]+distinctSet[len(distinctSet)-2])/2) +".."+str((distinctSet[len(distinctSet)-1]))
        for case in data:
            case[column] = symbols[str(case[column])]

# Computing Partitions
# Q is the set of all attributes(also called labels) and descisions (set of all cases?)
# U is the set of all cases (entities) (Description is more like set of all row numbers treated like pointers to the rows)
# P is an arbitrary nonempty subset of Q ( of U?)
# indiscernibility relation of P is an equivalence relation on U...it induces a partition of U generated by P and is called P* of U
# if U is known then you jsut call it partition P*.
# partition P* is the set of all equivalence classes. P is a function that returns the arbitrary subset so P is a palceholder for {a}* {b}* {a,b}* etc
# since it generates all of those it's known as P* with the expected {} contained inside the P otherwilse {P*} could produce {{a}*}
#
def getDStar(data):
    distinctSet = []
    for case in data:
        distinctSet.append( case[len(case)-1])
    distinctSet = list(set(distinctSet))
    DStar = [[] for x in range(len(distinctSet))]
    for case in data:
        DStar[distinctSet.index(case[len(case)-1])].append(case[len(case)-1])
    return DStar 

def generateAttributeCombos(attributes):
    combos = []
    for x in range(0,len(attributes)):
        combos = combos + list(combinations(attributes, x+1))
    return combos

def generatePartitionsForSet(labels, data):
    attributeGroups = generateAttributeCombos(labels[:len(labels)-1])
    
    numAttributes = len(labels)-1
    combos = math.pow(2,numAttributes)-1
    setStarHolder = [[] for x in combos]
    


def computePartitionAStar():
    pass

def computePartitionQStar():
    pass

def getSeta():
    pass

def AStarIsLessThanOrEqualToSetDStar(AStar, SetDStar):
    pass

def QStarIsLessThanOrEqualToSetDStar(QStar, SetDStar):
    pass

# U is the data table. 
# Each row is called a case( also an entity). 
# The last column of a row is typically the descision(outcome/result/choice). 
# The subset of all rows that have the same decision are called a concept.
# Equivalence classes are also called blocks
# {d}* is a set of subsets grouped by descision ie. {{yes, yes, yes}{no, no},{maybe}} but by their case row numbers instead like this {{row1, row3, row4}{row2, row6},{row5}}
# 
# set inequalities
# so {{1},{2},{3},{4},{5},{6},{7}} <= {{1,2,4,5},{3,6,7}} is true
# but {{1},{2},{3,6},{4},{5,7}} <= {{1,2,4,5},{3,6,7}} is not
# This is because there is no way to group the subsets of 
# {{1},{2},{3,6},{4},{5,7}} to create the subsets of  {{1,2,4,5},{3,6,7}}
#
# A note on Discernible... This is not distinct. In the case of 3 attributes and one descision(ex:{a,b,c,d}) {1,1,2,4} this is indiscernible from {1,1,3,4} for the {a,b} partition
# Note: The above example needs a lot of pretext.

# The input (Set of all attributes A, partiton {d}* on U [This is just a set of subsets of entities from U (the set of everything) grouped by descision])
def lem1(U, A, SetDStar):
    AStarPartitionSet = computePartitions()#will probably become a generate all discernable partitions and for each over them
    P = A
    R = 0
    if AStarIsLessThanOrEqualToSetDStar(AStar, SetDStar):#not the worst comparison function
        for a in AStar:
            Seta = getSeta()#a discernible subset of AStar?
            Q = P - Seta
            QStar = computePartitionQStar()#will probably become a generate all discernable partitions and for each over them
            if QStarIsLessThanOrEqualToSetDStar(QStar, SetDStar):#not the worst comparison function
                P = Q
        R = P
    return R

def main():
    data = importData(r"C:\Users\DrMur\DataMining\Programming Project\test.txt");
    Symbolicise(data[1])
    combos = generateAttributeCombos(data[0][:3])

    print(data)
    print(getDStar(data[1]))
    print(combos)
if __name__ == "__main__":
    main()




